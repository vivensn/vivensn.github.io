{"componentChunkName":"component---src-templates-post-template-js","path":"/blog/js-master-array-methods","result":{"data":{"markdownRemark":{"html":"<h1>Array Methods Which Every JS developer Must Master</h1>\n<p>Most applications deal with a list of values, which in JavaScript are often stored in an <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\">Array</a>. In order to write clean code, it is imperative that we, JavaScript developers, master the methods which the <code>Array.prototype</code> provides and know when it is appropriate to use each of them. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#\">MDN</a> provides an extensive documentation for these Array methods.\nFrom my experience I've come to love few of them for one main reason:\nthey don't change the existing array but return a new array with the needed values. If you have been developing with JavaScript for so long you might be used to the traditional <code>push</code> and <code>pop</code> which manipulate and mutate the array, it should no longer be the case.</p>\n<p>Since ES6, JavaScript has tremendously evolved, developers we must not stay behind but evolve with the language.\nPracticing and mastering these methods makes coding with Array in JavaScript much more fun.</p>\n<ol>\n<li>\n<p><strong>map()</strong></p>\n<p><code>map()</code> is a higher-order method function (means a function that accepts another function as a parameter) that creates a <strong>new array</strong> populated with the results of calling the provided function on every element in the calling array.</p>\n<pre><code class=\"language-js\">const fruits = ['apple', 'mango', 'orange', 'pear', 'pineapple']\n// Create a new array with uppercased fruit names\nconst array = fruits.map(fruit => fruit.toUpperCase())\nconsole.log(array) //output:  [\"APPLE\", \"MANGO\", \"ORANGE\", \"PEAR\", \"PINEAPPLE\"]\n</code></pre>\n</li>\n<li>\n<p><strong>filter()</strong></p>\n<p><code>filter()</code> is a higher-order method that creates a <strong>new array</strong> containing only the values which pass the test implemented by the provided predicate function.</p>\n<pre><code class=\"language-js\">const fruits = ['apple', 'mango', 'orange', 'pear', 'pineapple']\n// New array of fruits that start with the letter p\nconst array = fruits.filter(fruit => fruit.startsWith('p'))\nconsole.log(array) //output:  [\"pear\", \"pineapple\"]\n</code></pre>\n</li>\n<li>\n<p><strong>find()</strong></p>\n<p><code>find()</code> method returns the first value in the array that satisfies the test provided by the predicate function parameter</p>\n<pre><code class=\"language-js\">const fruits = ['apple', 'mango', 'orange', 'pear', 'pineapple']\n// Find the fruit that begins with m\nconst array = fruits.find(fruit => fruit.startsWith('m'))\nconsole.log(array) //output: mango\n</code></pre>\n<p>Notice the different between <code>filter</code> and <code>find</code>; <code>filter()</code> returns a new array of filtered values while <code>find()</code> a single value.</p>\n</li>\n<li>\n<p><strong>every()</strong></p>\n<p><code>every()</code> method checks if all the array's values pass the test of the predicate function parameter; Its return value is a boolean value: <code>true</code> or <code>false</code></p>\n<pre><code class=\"language-js\">const locations = [\n {\n   city: 'Kansas City',\n   state: 'MO',\n },\n {\n   city: 'Seattle',\n   state: 'WA',\n },\n {\n   city: 'Phoenix',\n   state: '',\n },\n {\n   city: 'Miami',\n   state: '',\n },\n {\n   city: 'Los Angeles',\n   state: 'CA',\n },\n]\n\n// Check every location has a state value\nconst stateCheck = locations.every(location => location.state)\nconsole.log(stateCheck) //output: false\n</code></pre>\n</li>\n<li>\n<p><strong>some()</strong></p>\n<p><code>some()</code> method tests if at least one value in the array satisfies the test of the predicate function parameter. Same as <code>every()</code> it always returns a Boolean value</p>\n<pre><code class=\"language-js\">// Check if some locations have state value\nconst stateCheck = locations.every(location => location.state)\nconsole.log(stateCheck) //output: true\n</code></pre>\n</li>\n<li>\n<p><strong>reduce()</strong></p>\n<p><code>reduce()</code> method, as its name implies, reduces the array to single value by executing the provided function parameter on every value in the array from left to right and storing the return value in an accumulator (result). Again <code>reduce</code> does not change the original array.</p>\n<pre><code class=\"language-js\">const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nconst sum = numbers.reduce((total, value) => total + value, 0)\nconsole.log(sum) //output: 55\n</code></pre>\n</li>\n<li>\n<p><strong>sort()</strong></p>\n<p><code>sort()</code> method sorts the array's values in place either in the ascending order or in the descending order.</p>\n<pre><code class=\"language-js\">const fruits = ['Banana', 'Orange', 'Apple', 'Mango']\nconsole.log(fruits.sort()) //output: [\"Apple\", \"Banana\", \"Mango\", \"Orange\"]\n</code></pre>\n<p>It is important to note that by default <code>sort()</code> sorts the array's values as strings.\nFor this reason, if numbers are sorted as strings, \"25\" is bigger than \"100\", because \"2\" is bigger than \"1\", and the sorting result for numbers will be incorrect.</p>\n<p>The good news <code>sort()</code> accepts compare function parameter that can be used to address the issue.</p>\n<pre><code class=\"language-js\">const points = [40, 100, 1, 5, 25, 10]\nconst sortedPoints = points.sort(function(a, b) {\n return a - b\n})\nconsole.log(sortedPoints) //output: [1, 5, 10, 25, 40, 100]\n</code></pre>\n</li>\n<li>\n<p><strong>concat()</strong></p>\n<p><code>concat()</code> method returns a new array containing this array joined with one or multiple other arrays.</p>\n<pre><code class=\"language-js\">const fruits1 = ['apple', 'mango', 'orange', 'pear', 'pineapple']\nconst fruits2 = ['kiwi', 'strawberry']\nconst fruits3 = fruits1.concat(fruits2)\nconsole.log(fruits3) //output: [\"apple\", \"mango\", \"orange\", \"pear\", \"pineapple\", \"kiwi\", \"strawberry\"]\n</code></pre>\n<p><em>Bonus</em>: Another way to combine multiple arrays into one consists of using the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\">spread</a> operator, preferably you should choose to use <code>spread</code> over <code>concat()</code> because the <code>spread</code> syntax is more concise and easier to write.\nThe only advantage of <code>concat()</code> is that takes both <code>array</code> and <code>non-array</code> values.\nThe quick rule to choose is that you are dealing with arrays only, use spread; if there is the possibility of a non-array, use <code>concat()</code> for merging.</p>\n</li>\n</ol>\n<p>For conclusion, master the Array methods and have fun building.</p>","frontmatter":{"date":"March 12, 2020","path":"/blog/js-master-array-methods","title":"Array Methods Which Every JS developer Must Master"}}},"pageContext":{}}}